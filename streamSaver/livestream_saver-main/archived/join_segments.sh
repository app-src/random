#!/bin/zsh
#
# NOTE: this script is currently made obsolete by the pre-merge script linked below.
# It could be tweaked to work by mimicking what is done in
# https://github.com/mrwnwttk/youtube_stream_capture/blob/main/merge.py
#

# Join parts generated by the script: https://gist.github.com/cheadrian/b661fb68a6a87ea64069e641cef68c3e#gistcomment-3495351

mkdir -p vid_fix
base_dir=$(pwd)
vid_dir="${base_dir}/stream_download_test/vid/"
aud_dir="${base_dir}/stream_download_test/aud/"
# number of files to skip from the start and end
skip_start=58
skip_end=0

# List audio and video source files and format it for ffmpeg
if [[ ! -f ${vid_dir}vid_list.txt ]]; then
	# ignore the file being created, otherwise it will be included!
	ls -v ${vid_dir} | grep -v ".txt" > ${vid_dir}vid_list.txt;
	sed -i "s/.*/file '&'/" ${vid_dir}vid_list.txt;

	if [[ "${skip_start}" -ne 0 ]]; then
		# Remove the Nth lines from the start
		echo "Discarding ${skip_start} video files from the first line...";
	 	sed -i "1,${skip_start}d" ${vid_dir}vid_list.txt;
	fi

	if [ "${skip_end}" -ne 0 ]; then
	# Remove the Nth lines at the end
	echo "Discarding ${skip_end} video files at the end...";
 	sed -i "$(($(wc -l < ${vid_dir}vid_list.txt)-${skip_end})),\$d" ${vid_dir}vid_list.txt;
	fi
fi

if [[ ! -f ${aud_dir}aud_list.txt ]]; then
	# ignore the file being created, otherwise it will be included!
	ls -v ${aud_dir} | grep -v ".txt" > ${aud_dir}aud_list.txt;
	sed -i "s/.*/file '&'/" ${aud_dir}aud_list.txt;

	if [[ "${skip_start}" -ne 0 ]]; then
		# Remove the Nth lines from the start
		echo "Discarding ${skip_start} audio files from the first line...";
	 	sed -i "1,${skip_start}d" ${aud_dir}aud_list.txt;
	fi

	if [ "${skip_end}" -ne 0 ]; then
	# Remove the Nth lines at the end
	echo "Discarding ${skip_end} audio files at the end...";
 	sed -i "$(($(wc -l < ${vid_dir}vid_list.txt)-${skip_end})),\$d" ${aud_dir}aud_list.txt;
	fi
fi

# Convert video pieces to better format (in case we need)
# for f in ${vid_dir}*.mp4; do ffmpeg -i "${f}" -an -c:v libx264 -crf 18 ${f#${vid_dir}}; done;

# Concatenate into one video file
video_output="output.ts"
if [ ! -e ${vid_dir}${video_output} ]; then
	cd ${vid_dir};
	# ffmpeg -f concat -i vid_list.txt -c:v libx264 -crf 16 -an -f mpegts output.mpg;
	ffmpeg -hide_banner -auto_convert 1 -f concat -i vid_list.txt -c copy -bsf h264_mp4toannexb -an -f mpegts ${video_output};
	cd ${base_dir};
else
	echo "${video_output} already exists. Skipping creation.";
fi

# Concatenate and encode into mp3 to remove timestamps embedded in the original files, doesn't seem to work with m4a format
audio_output="output.mp3"
if [ ! -e ${aud_dir}${audio_output} ]; then
	cd ${aud_dir};
	# ffmpeg -hide_banner -f concat -i aud_list.txt -c copy ${audio_output};
	ffmpeg -hide_banner -f concat -i aud_list.txt -acodec libmp3lame -b:a 128k output.mp3;
	cd ${base_dir};
else
	echo "${audio_output} already exists. Skipping creation.";
fi

# ffmpeg -i ${vid_dir}output.mp4 -i ${aud_dir}output.m4a -filter_complex \
# "[0:v][1:a] concat=n=2:v=1:a=1 [outv] [outa]" -map "[outv]" -map "[outa]" out.mp4

# Mux for final file. Specifying 60 fps seems to be required here to ignore original timestamps in video stream
final_output="stream_output_final.mp4"
echo "Muxing final file ${final_output}"
ffmpeg -hide_banner -i "${vid_dir}output.ts" -r:0 60 -vn -i "${aud_dir}${audio_output}" -c:v libx264 -crf 18 -c:a copy ${final_output};


# =============================
# Archived notes:
# =============================

## Easier way could be with a bash for loop
# for f in ./*.wav; do echo "file '$f'" >> mylist.txt; done
## or
# printf "file '%s'\n" ./*.wav > mylist.txt

## Store files in an array
# files=(*.c)
# for f in “${files[@]}”; do cmd “$f”; done
## Or just use glob
# for f in *.c; do cmd “$f”; done
